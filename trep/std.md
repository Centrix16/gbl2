# Стандарт деревьев для layp & trep
## v0.2

#### ! Обозначения

Следующее дерево

```
  a
 / \
b   c
```
будет далее обозначаться следующим образом:

```
a
 b
 c
```

#### ! Сигнатуры функций будут обозначаться так:
```
func_name(func_arg1, func_arg2, ... , func_argN)
```

#### ! В этом документе будет использована двуменая нотация layp
```
lay1
elm1 elm2
fork1|fork2;

// Это описание следующего дерева:
lay1
 elm1
  fork1
 elm2
  fork2
```

## Основные функции:
  + `output(stream, str1, ... , strN)` -- где `stream` - поток вывода (`out / in / err`), а `str1 - strN` - строки содержащие текст для вывода
  + `input(stream)` -- где `stream` - поток ввода (`out / in / err`), а ввод возвращается в качестве результата
  + `def(func_name, func_arg, func_body)` -- где `func_name` - имя функции. `func_arg` - список аргументов функции (одним токеном), а `func_body` - тело функции (одним токеном)
  + `let(var_name, var_value, ...)` -- где `var_name` - имя создаваемой переменной, а `var_value` - начальное значение создаваемой переменной
  + `return(val1, val2, ... , valN)` -- где `val1 - valN` - возвращаемые функцией значения
  + `+, -, *, / (arg1, ... , argN)` -- математические функции принимающие в качестве операндов `arg1 - argN`
  + `exit(code)` -- немедленный выход из программы, с возвращением кода code
  + `eval(expr)` -- вычисление выражения expr, по факту - eval интерпретатор trep / layp
  + `;(expr)` -- запрет вычисления
  + `~ "text"` -- комментарий
  + `> / < / = / !=` -- функции сравнения принимают 2 аргумента, возвращают 1 | 0
  + `& / | / !` -- логические функции принимают N аргументов, возвращают 1 | 0
  + `?` -- ветвление
  + `while` -- цикл while
  + `for` -- цикл for

## Деревья функций

  ```
  // output or input
  output / input
   stream
   str1
   ...
   strN

  // def
  def
   func_name
   func_arg
   func_body

  // let
  let
   var_name
   var_value
   ...

  // return
  return
   val1
   ...
   valN

  // math
   + or - or * or /
    arg1
	...
	argN

  // eval
  eval
   expr

  // exit
  exit
   code

  // ;
  ;
   expr

  // cmp
  < / > / = / !=
   arg1
   arg2

  // logic
  & / | / !
   arg1
   ...
   argN

  // ?
  ?
   cond1
   body1
   ...
   condN
   bodyN
   ...
   else-body

  // while
  while
   cond
   body

  // for
  for
   var_init
   cond
   inc
   body
  ```

## Пример кода на trep
  ```
  let (a)(12) (b)(13)

  def (calc)(op1 op2) ( ; (
     return (+ (op1)(op2))  
  ))

  let (result)(calc (a)(b))
  output (result)
  ```

## Пример кода на layp
  ```
  let
  a 12 b 13;

  def
  calc "op1 op2" "
      return
	  +
	  op1 op2
  ";

  let
  result "calc
      a b
  ";

  output
  result;
  ```

## Уточнение по поводу def
  Как уже было написано, список аргументов функции передаётся одним токеном, т.е. следующая функция:
  ```
  f(a, b) = ... // математическая нотация

  // будет в виде дерева выглядеть так
  f
   a b // список аргументов одним токеном
   ...

  // а в коде на trep так
  def (f)(a b)(...)

  // соответственно в layp
  def
  f "a b" "...";
  ```

## Уточнение по поводу let
   + Функция let принимает произвольное количество пар аргументов, т.е. если надо создать `a = 12, b = 13` то:
  ```
  // дерево будет таким
  let
   a
   12
   b
   13

  // код на trep
  let (a)(12) (b)(13)

  // код на layp
  let
  a 12 b 13;
  ```

  + При множественном присваивании:

  ```
  // дерево функции
  let
   a b c // список переменных
   5 // их значение

  // a = b = c:
  let
   a b
   c

  // trep
  let (a b c)(5)
  let (a b)(c)

  // layp
  let
  a b c|5;

  let
  a b|c;
  ```

## Вопрос комментариев
  Основу философии trep и layp состовляет синтаксическое однообразие языка, поэтому комментарии должны быть построены по принципу, которому следую все остальные возможности языка. Вопрос состоит только лишь в том, чем обозначать комментарии
  ```
  //
  ~
  #
  %
  '
  !
  ```

## Ход работ  
  __v__  Написание парсера  
  __vx__ Написание генератора деревьев  
  __xv__ Написание базовой библиотеки `bl.c`  
  __x__  Написание расширенной библиотеки `al.c`  
